// automatically generated by Xtext
grammar hu.bme.mit.ltl.Ltl with org.eclipse.xtext.common.Terminals

import "hu.bme.mit.ltl" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*LTLExpression returns LTLExpression:
	TemporalBinaryExpression
;

TemporalBinaryExpression returns LTLExpression:
	TemporalUnaryExpression(
		({UntilExpression.leftOperand=current} (('U') rightOperand=LTLExpression)) |
		({ImplyExpression.leftOperand=current} (('->' | '=>' | 'implies') rightOperand=LTLExpression)) | 
		({EquivalenceExpression.leftOperand = current} (('<->' | '<=>' | 'iff') rightOperand=LTLExpression))
	)?
;

TemporalUnaryExpression returns LTLExpression:
	FutureExpression |
	GloballyExpression |
	NextExpression |
	BooleanBinaryExpression
;

FutureExpression returns LTLExpression:
	{FutureExpression} 'F' operand=TemporalUnaryExpression
;

GloballyExpression returns LTLExpression:
	{GloballyExpression} 'G' operand=TemporalUnaryExpression
;

NextExpression returns LTLExpression:
	{NextExpression} 'X' operand=TemporalUnaryExpression
;

BooleanBinaryExpression returns LTLExpression:
	AndExpression(
		//( {AndExpression.leftOperand=current} (('&' | 'and') rightOperand=LTLExpression) )|
		( {OrExpression.leftOperand= current} (('|' | 'or') rightOperand=LTLExpression) )
	)*
;

AndExpression returns LTLExpression:
	PrimaryExpression(
		 {AndExpression.leftOperand=current} => (('&' | 'and') rightOperand=LTLExpression) 
	)*
;

PrimaryExpression returns LTLExpression:
	('(' LTLExpression ')') |
	=>({NotExpression} ('not' | '!') operand=PrimaryExpression) |		//whenever possible, assign to primary (high op priority)
	({NotExpression} ('not' | '!') operand=TemporalUnaryExpression) |	//when not, assign temporal (low op priority)
	LiteralExpression
;*/

LTLExpression returns LTLExpression:
	ArrowExpression
;

ArrowExpression returns LTLExpression:
	OrExpression(
		{ImplyExpression.leftOperand=current} '->' rightOperand=ArrowExpression |
		{EquivalenceExpression.leftOperand=current} '<->' rightOperand=ArrowExpression
	)?
;

//TODO xor above this
OrExpression returns LTLExpression:
	AndExpression(
		{OrExpression.leftOperand=current} '|' rightOperand=AndExpression
	)*
;

AndExpression returns LTLExpression:
	UntilExpression(
		{AndExpression.leftOperand=current} '&' rightOperand=UntilExpression
	)*
;

//TODO extend with W, M, R
UntilExpression returns LTLExpression:
	FutureGloballyExpression(
		{UntilExpression.leftOperand=current} 'U' rightOperand=UntilExpression
	)?
;

FutureGloballyExpression returns LTLExpression:
	/*NextExpression(
		 'F' operand=NextExpression //|
		// 'G' {GloballyExpression.operand=current}
	)?*/
	'F' {FutureExpression}  operand=NextExpression |
	'G' {GloballyExpression} operand=NextExpression | 
	NextExpression
;

NextExpression returns LTLExpression:
	'X' {NextExpression}  operand=PrimaryExpression |
	PrimaryExpression
	/*PrimaryExpression(
		'X' {NextExpression.operand=current} 
	)?*/
;

PrimaryExpression returns LTLExpression:
	'(' LTLExpression ')' |
	{NotExpression} '!' operand=PrimaryExpression |
	LiteralExpression
;
///////////////
LiteralExpression returns LTLExpression:
	AtomicProposition |
	TrueExpression |
	FalseExpression
;

FalseExpression returns LTLExpression:
	{FalseExpression} 'false'
;

TrueExpression returns LTLExpression:
	{TrueExpression} 'true'
;

AtomicProposition returns LTLExpression:
	{AtomicProposition}
	proposition = EString
;

EString returns ecore::EString:
	STRING | ID
;