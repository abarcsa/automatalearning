/*
 * generated by Xtext 2.23.0
 */
package hu.bme.mit.ltl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LtlGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class LTLExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.LTLExpression");
		private final RuleCall cArrowExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///*LTLExpression returns LTLExpression:
		//	TemporalBinaryExpression
		//;
		//
		//TemporalBinaryExpression returns LTLExpression:
		//	TemporalUnaryExpression(
		//		({UntilExpression.leftOperand=current} (('U') rightOperand=LTLExpression)) |
		//		({ImplyExpression.leftOperand=current} (('->' | '=>' | 'implies') rightOperand=LTLExpression)) | 
		//		({EquivalenceExpression.leftOperand = current} (('<->' | '<=>' | 'iff') rightOperand=LTLExpression))
		//	)?
		//;
		//
		//TemporalUnaryExpression returns LTLExpression:
		//	FutureExpression |
		//	GloballyExpression |
		//	NextExpression |
		//	BooleanBinaryExpression
		//;
		//
		//FutureExpression returns LTLExpression:
		//	{FutureExpression} 'F' operand=TemporalUnaryExpression
		//;
		//
		//GloballyExpression returns LTLExpression:
		//	{GloballyExpression} 'G' operand=TemporalUnaryExpression
		//;
		//
		//NextExpression returns LTLExpression:
		//	{NextExpression} 'X' operand=TemporalUnaryExpression
		//;
		//
		//BooleanBinaryExpression returns LTLExpression:
		//	AndExpression(
		//		//( {AndExpression.leftOperand=current} (('&' | 'and') rightOperand=LTLExpression) )|
		//		( {OrExpression.leftOperand= current} (('|' | 'or') rightOperand=LTLExpression) )
		//	)*
		//;
		//
		//AndExpression returns LTLExpression:
		//	PrimaryExpression(
		//		 {AndExpression.leftOperand=current} => (('&' | 'and') rightOperand=LTLExpression) 
		//	)*
		//;
		//
		//PrimaryExpression returns LTLExpression:
		//	('(' LTLExpression ')') |
		//	=>({NotExpression} ('not' | '!') operand=PrimaryExpression) |		//whenever possible, assign to primary (high op priority)
		//	({NotExpression} ('not' | '!') operand=TemporalUnaryExpression) |	//when not, assign temporal (low op priority)
		//	LiteralExpression
		//;*/ LTLExpression:
		//	ArrowExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//ArrowExpression
		public RuleCall getArrowExpressionParserRuleCall() { return cArrowExpressionParserRuleCall; }
	}
	public class ArrowExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.ArrowExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cImplyExpressionLeftOperandAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightOperandArrowExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRightOperandAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cEquivalenceExpressionLeftOperandAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLessThanSignHyphenMinusGreaterThanSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightOperandArrowExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRightOperandAssignment_1_1_2.eContents().get(0);
		
		//ArrowExpression LTLExpression:
		//	OrExpression ({ImplyExpression.leftOperand=current} '->' rightOperand=ArrowExpression |
		//	{EquivalenceExpression.leftOperand=current} '<->' rightOperand=ArrowExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression ({ImplyExpression.leftOperand=current} '->' rightOperand=ArrowExpression |
		//{EquivalenceExpression.leftOperand=current} '<->' rightOperand=ArrowExpression)?
		public Group getGroup() { return cGroup; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }
		
		//({ImplyExpression.leftOperand=current} '->' rightOperand=ArrowExpression | {EquivalenceExpression.leftOperand=current}
		//'<->' rightOperand=ArrowExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//{ImplyExpression.leftOperand=current} '->' rightOperand=ArrowExpression
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ImplyExpression.leftOperand=current}
		public Action getImplyExpressionLeftOperandAction_1_0_0() { return cImplyExpressionLeftOperandAction_1_0_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0_1() { return cHyphenMinusGreaterThanSignKeyword_1_0_1; }
		
		//rightOperand=ArrowExpression
		public Assignment getRightOperandAssignment_1_0_2() { return cRightOperandAssignment_1_0_2; }
		
		//ArrowExpression
		public RuleCall getRightOperandArrowExpressionParserRuleCall_1_0_2_0() { return cRightOperandArrowExpressionParserRuleCall_1_0_2_0; }
		
		//{EquivalenceExpression.leftOperand=current} '<->' rightOperand=ArrowExpression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{EquivalenceExpression.leftOperand=current}
		public Action getEquivalenceExpressionLeftOperandAction_1_1_0() { return cEquivalenceExpressionLeftOperandAction_1_1_0; }
		
		//'<->'
		public Keyword getLessThanSignHyphenMinusGreaterThanSignKeyword_1_1_1() { return cLessThanSignHyphenMinusGreaterThanSignKeyword_1_1_1; }
		
		//rightOperand=ArrowExpression
		public Assignment getRightOperandAssignment_1_1_2() { return cRightOperandAssignment_1_1_2; }
		
		//ArrowExpression
		public RuleCall getRightOperandArrowExpressionParserRuleCall_1_1_2_0() { return cRightOperandArrowExpressionParserRuleCall_1_1_2_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		////TODO xor above this
		//OrExpression LTLExpression:
		//	AndExpression ({OrExpression.leftOperand=current} '|' rightOperand=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression ({OrExpression.leftOperand=current} '|' rightOperand=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//({OrExpression.leftOperand=current} '|' rightOperand=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{OrExpression.leftOperand=current}
		public Action getOrExpressionLeftOperandAction_1_0() { return cOrExpressionLeftOperandAction_1_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }
		
		//rightOperand=AndExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }
		
		//AndExpression
		public RuleCall getRightOperandAndExpressionParserRuleCall_1_2_0() { return cRightOperandAndExpressionParserRuleCall_1_2_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUntilExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandUntilExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		//AndExpression LTLExpression:
		//	UntilExpression ({AndExpression.leftOperand=current} '&' rightOperand=UntilExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//UntilExpression ({AndExpression.leftOperand=current} '&' rightOperand=UntilExpression)*
		public Group getGroup() { return cGroup; }
		
		//UntilExpression
		public RuleCall getUntilExpressionParserRuleCall_0() { return cUntilExpressionParserRuleCall_0; }
		
		//({AndExpression.leftOperand=current} '&' rightOperand=UntilExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AndExpression.leftOperand=current}
		public Action getAndExpressionLeftOperandAction_1_0() { return cAndExpressionLeftOperandAction_1_0; }
		
		//'&'
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }
		
		//rightOperand=UntilExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }
		
		//UntilExpression
		public RuleCall getRightOperandUntilExpressionParserRuleCall_1_2_0() { return cRightOperandUntilExpressionParserRuleCall_1_2_0; }
	}
	public class UntilExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.UntilExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFutureGloballyExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUntilExpressionLeftOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cUKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOperandUntilExpressionParserRuleCall_1_2_0 = (RuleCall)cRightOperandAssignment_1_2.eContents().get(0);
		
		////TODO extend with W, M, R
		//UntilExpression LTLExpression:
		//	FutureGloballyExpression ({UntilExpression.leftOperand=current} 'U' rightOperand=UntilExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//FutureGloballyExpression ({UntilExpression.leftOperand=current} 'U' rightOperand=UntilExpression)?
		public Group getGroup() { return cGroup; }
		
		//FutureGloballyExpression
		public RuleCall getFutureGloballyExpressionParserRuleCall_0() { return cFutureGloballyExpressionParserRuleCall_0; }
		
		//({UntilExpression.leftOperand=current} 'U' rightOperand=UntilExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{UntilExpression.leftOperand=current}
		public Action getUntilExpressionLeftOperandAction_1_0() { return cUntilExpressionLeftOperandAction_1_0; }
		
		//'U'
		public Keyword getUKeyword_1_1() { return cUKeyword_1_1; }
		
		//rightOperand=UntilExpression
		public Assignment getRightOperandAssignment_1_2() { return cRightOperandAssignment_1_2; }
		
		//UntilExpression
		public RuleCall getRightOperandUntilExpressionParserRuleCall_1_2_0() { return cRightOperandUntilExpressionParserRuleCall_1_2_0; }
	}
	public class FutureGloballyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.FutureGloballyExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cFKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cFutureExpressionAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandNextExpressionParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cGKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cGloballyExpressionAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperandNextExpressionParserRuleCall_1_2_0 = (RuleCall)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cNextExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//FutureGloballyExpression LTLExpression: /*NextExpression(
		//		 'F' operand=NextExpression //|
		//		// 'G' {GloballyExpression.operand=current}
		//	)?*/ 'F' {FutureExpression} operand=NextExpression | 'G' {GloballyExpression} operand=NextExpression | NextExpression;
		@Override public ParserRule getRule() { return rule; }
		
		///*NextExpression(
		//		 'F' operand=NextExpression //|
		//		// 'G' {GloballyExpression.operand=current}
		//	)?*/ 'F' {FutureExpression} operand=NextExpression | 'G' {GloballyExpression} operand=NextExpression | NextExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		///*NextExpression(
		//		 'F' operand=NextExpression //|
		//		// 'G' {GloballyExpression.operand=current}
		//	)?*/ 'F' {FutureExpression} operand=NextExpression
		public Group getGroup_0() { return cGroup_0; }
		
		///*NextExpression(
		//		 'F' operand=NextExpression //|
		//		// 'G' {GloballyExpression.operand=current}
		//	)?*/ 'F'
		public Keyword getFKeyword_0_0() { return cFKeyword_0_0; }
		
		//{FutureExpression}
		public Action getFutureExpressionAction_0_1() { return cFutureExpressionAction_0_1; }
		
		//operand=NextExpression
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//NextExpression
		public RuleCall getOperandNextExpressionParserRuleCall_0_2_0() { return cOperandNextExpressionParserRuleCall_0_2_0; }
		
		//'G' {GloballyExpression} operand=NextExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//'G'
		public Keyword getGKeyword_1_0() { return cGKeyword_1_0; }
		
		//{GloballyExpression}
		public Action getGloballyExpressionAction_1_1() { return cGloballyExpressionAction_1_1; }
		
		//operand=NextExpression
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//NextExpression
		public RuleCall getOperandNextExpressionParserRuleCall_1_2_0() { return cOperandNextExpressionParserRuleCall_1_2_0; }
		
		//NextExpression
		public RuleCall getNextExpressionParserRuleCall_2() { return cNextExpressionParserRuleCall_2; }
	}
	public class NextExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.NextExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cXKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cNextExpressionAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandPrimaryExpressionParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final RuleCall cPrimaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NextExpression LTLExpression:
		//	'X' {NextExpression} operand=PrimaryExpression | PrimaryExpression
		//	/*PrimaryExpression(
		//		'X' {NextExpression.operand=current} 
		//	)?*/;
		@Override public ParserRule getRule() { return rule; }
		
		//'X' {NextExpression} operand=PrimaryExpression | PrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'X' {NextExpression} operand=PrimaryExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//'X'
		public Keyword getXKeyword_0_0() { return cXKeyword_0_0; }
		
		//{NextExpression}
		public Action getNextExpressionAction_0_1() { return cNextExpressionAction_0_1; }
		
		//operand=PrimaryExpression
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//PrimaryExpression
		public RuleCall getOperandPrimaryExpressionParserRuleCall_0_2_0() { return cOperandPrimaryExpressionParserRuleCall_0_2_0; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_1() { return cPrimaryExpressionParserRuleCall_1; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLTLExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperandPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cOperandAssignment_1_2.eContents().get(0);
		private final RuleCall cLiteralExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrimaryExpression LTLExpression:
		//	'(' LTLExpression ')' | {NotExpression} '!' operand=PrimaryExpression | LiteralExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' LTLExpression ')' | {NotExpression} '!' operand=PrimaryExpression | LiteralExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' LTLExpression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//LTLExpression
		public RuleCall getLTLExpressionParserRuleCall_0_1() { return cLTLExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{NotExpression} '!' operand=PrimaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{NotExpression}
		public Action getNotExpressionAction_1_0() { return cNotExpressionAction_1_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }
		
		//operand=PrimaryExpression
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }
		
		//PrimaryExpression
		public RuleCall getOperandPrimaryExpressionParserRuleCall_1_2_0() { return cOperandPrimaryExpressionParserRuleCall_1_2_0; }
		
		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_2() { return cLiteralExpressionParserRuleCall_2; }
	}
	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicPropositionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTrueExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFalseExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/////////////////
		//LiteralExpression LTLExpression:
		//	AtomicProposition | TrueExpression | FalseExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//AtomicProposition | TrueExpression | FalseExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AtomicProposition
		public RuleCall getAtomicPropositionParserRuleCall_0() { return cAtomicPropositionParserRuleCall_0; }
		
		//TrueExpression
		public RuleCall getTrueExpressionParserRuleCall_1() { return cTrueExpressionParserRuleCall_1; }
		
		//FalseExpression
		public RuleCall getFalseExpressionParserRuleCall_2() { return cFalseExpressionParserRuleCall_2; }
	}
	public class FalseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.FalseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//FalseExpression LTLExpression:
		//	{FalseExpression} 'false';
		@Override public ParserRule getRule() { return rule; }
		
		//{FalseExpression} 'false'
		public Group getGroup() { return cGroup; }
		
		//{FalseExpression}
		public Action getFalseExpressionAction_0() { return cFalseExpressionAction_0; }
		
		//'false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	public class TrueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.TrueExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TrueExpression LTLExpression:
		//	{TrueExpression} 'true';
		@Override public ParserRule getRule() { return rule; }
		
		//{TrueExpression} 'true'
		public Group getGroup() { return cGroup; }
		
		//{TrueExpression}
		public Action getTrueExpressionAction_0() { return cTrueExpressionAction_0; }
		
		//'true'
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}
	public class AtomicPropositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.AtomicProposition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtomicPropositionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPropositionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPropositionEStringParserRuleCall_1_0 = (RuleCall)cPropositionAssignment_1.eContents().get(0);
		
		//AtomicProposition LTLExpression:
		//	{AtomicProposition} proposition=EString;
		@Override public ParserRule getRule() { return rule; }
		
		//{AtomicProposition} proposition=EString
		public Group getGroup() { return cGroup; }
		
		//{AtomicProposition}
		public Action getAtomicPropositionAction_0() { return cAtomicPropositionAction_0; }
		
		//proposition=EString
		public Assignment getPropositionAssignment_1() { return cPropositionAssignment_1; }
		
		//EString
		public RuleCall getPropositionEStringParserRuleCall_1_0() { return cPropositionEStringParserRuleCall_1_0; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.ltl.Ltl.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EString:
		//	STRING | ID;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	
	
	private final LTLExpressionElements pLTLExpression;
	private final ArrowExpressionElements pArrowExpression;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final UntilExpressionElements pUntilExpression;
	private final FutureGloballyExpressionElements pFutureGloballyExpression;
	private final NextExpressionElements pNextExpression;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final LiteralExpressionElements pLiteralExpression;
	private final FalseExpressionElements pFalseExpression;
	private final TrueExpressionElements pTrueExpression;
	private final AtomicPropositionElements pAtomicProposition;
	private final EStringElements pEString;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LtlGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pLTLExpression = new LTLExpressionElements();
		this.pArrowExpression = new ArrowExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pUntilExpression = new UntilExpressionElements();
		this.pFutureGloballyExpression = new FutureGloballyExpressionElements();
		this.pNextExpression = new NextExpressionElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pFalseExpression = new FalseExpressionElements();
		this.pTrueExpression = new TrueExpressionElements();
		this.pAtomicProposition = new AtomicPropositionElements();
		this.pEString = new EStringElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("hu.bme.mit.ltl.Ltl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///*LTLExpression returns LTLExpression:
	//	TemporalBinaryExpression
	//;
	//
	//TemporalBinaryExpression returns LTLExpression:
	//	TemporalUnaryExpression(
	//		({UntilExpression.leftOperand=current} (('U') rightOperand=LTLExpression)) |
	//		({ImplyExpression.leftOperand=current} (('->' | '=>' | 'implies') rightOperand=LTLExpression)) | 
	//		({EquivalenceExpression.leftOperand = current} (('<->' | '<=>' | 'iff') rightOperand=LTLExpression))
	//	)?
	//;
	//
	//TemporalUnaryExpression returns LTLExpression:
	//	FutureExpression |
	//	GloballyExpression |
	//	NextExpression |
	//	BooleanBinaryExpression
	//;
	//
	//FutureExpression returns LTLExpression:
	//	{FutureExpression} 'F' operand=TemporalUnaryExpression
	//;
	//
	//GloballyExpression returns LTLExpression:
	//	{GloballyExpression} 'G' operand=TemporalUnaryExpression
	//;
	//
	//NextExpression returns LTLExpression:
	//	{NextExpression} 'X' operand=TemporalUnaryExpression
	//;
	//
	//BooleanBinaryExpression returns LTLExpression:
	//	AndExpression(
	//		//( {AndExpression.leftOperand=current} (('&' | 'and') rightOperand=LTLExpression) )|
	//		( {OrExpression.leftOperand= current} (('|' | 'or') rightOperand=LTLExpression) )
	//	)*
	//;
	//
	//AndExpression returns LTLExpression:
	//	PrimaryExpression(
	//		 {AndExpression.leftOperand=current} => (('&' | 'and') rightOperand=LTLExpression) 
	//	)*
	//;
	//
	//PrimaryExpression returns LTLExpression:
	//	('(' LTLExpression ')') |
	//	=>({NotExpression} ('not' | '!') operand=PrimaryExpression) |		//whenever possible, assign to primary (high op priority)
	//	({NotExpression} ('not' | '!') operand=TemporalUnaryExpression) |	//when not, assign temporal (low op priority)
	//	LiteralExpression
	//;*/ LTLExpression:
	//	ArrowExpression;
	public LTLExpressionElements getLTLExpressionAccess() {
		return pLTLExpression;
	}
	
	public ParserRule getLTLExpressionRule() {
		return getLTLExpressionAccess().getRule();
	}
	
	//ArrowExpression LTLExpression:
	//	OrExpression ({ImplyExpression.leftOperand=current} '->' rightOperand=ArrowExpression |
	//	{EquivalenceExpression.leftOperand=current} '<->' rightOperand=ArrowExpression)?;
	public ArrowExpressionElements getArrowExpressionAccess() {
		return pArrowExpression;
	}
	
	public ParserRule getArrowExpressionRule() {
		return getArrowExpressionAccess().getRule();
	}
	
	////TODO xor above this
	//OrExpression LTLExpression:
	//	AndExpression ({OrExpression.leftOperand=current} '|' rightOperand=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//AndExpression LTLExpression:
	//	UntilExpression ({AndExpression.leftOperand=current} '&' rightOperand=UntilExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	////TODO extend with W, M, R
	//UntilExpression LTLExpression:
	//	FutureGloballyExpression ({UntilExpression.leftOperand=current} 'U' rightOperand=UntilExpression)?;
	public UntilExpressionElements getUntilExpressionAccess() {
		return pUntilExpression;
	}
	
	public ParserRule getUntilExpressionRule() {
		return getUntilExpressionAccess().getRule();
	}
	
	//FutureGloballyExpression LTLExpression: /*NextExpression(
	//		 'F' operand=NextExpression //|
	//		// 'G' {GloballyExpression.operand=current}
	//	)?*/ 'F' {FutureExpression} operand=NextExpression | 'G' {GloballyExpression} operand=NextExpression | NextExpression;
	public FutureGloballyExpressionElements getFutureGloballyExpressionAccess() {
		return pFutureGloballyExpression;
	}
	
	public ParserRule getFutureGloballyExpressionRule() {
		return getFutureGloballyExpressionAccess().getRule();
	}
	
	//NextExpression LTLExpression:
	//	'X' {NextExpression} operand=PrimaryExpression | PrimaryExpression
	//	/*PrimaryExpression(
	//		'X' {NextExpression.operand=current} 
	//	)?*/;
	public NextExpressionElements getNextExpressionAccess() {
		return pNextExpression;
	}
	
	public ParserRule getNextExpressionRule() {
		return getNextExpressionAccess().getRule();
	}
	
	//PrimaryExpression LTLExpression:
	//	'(' LTLExpression ')' | {NotExpression} '!' operand=PrimaryExpression | LiteralExpression;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	/////////////////
	//LiteralExpression LTLExpression:
	//	AtomicProposition | TrueExpression | FalseExpression;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}
	
	//FalseExpression LTLExpression:
	//	{FalseExpression} 'false';
	public FalseExpressionElements getFalseExpressionAccess() {
		return pFalseExpression;
	}
	
	public ParserRule getFalseExpressionRule() {
		return getFalseExpressionAccess().getRule();
	}
	
	//TrueExpression LTLExpression:
	//	{TrueExpression} 'true';
	public TrueExpressionElements getTrueExpressionAccess() {
		return pTrueExpression;
	}
	
	public ParserRule getTrueExpressionRule() {
		return getTrueExpressionAccess().getRule();
	}
	
	//AtomicProposition LTLExpression:
	//	{AtomicProposition} proposition=EString;
	public AtomicPropositionElements getAtomicPropositionAccess() {
		return pAtomicProposition;
	}
	
	public ParserRule getAtomicPropositionRule() {
		return getAtomicPropositionAccess().getRule();
	}
	
	//EString:
	//	STRING | ID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
